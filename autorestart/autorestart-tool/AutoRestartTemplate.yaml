AWSTemplateFormatVersion: '2010-09-09'
Description: CloudFormation template with resources necessary to perform instance auto-restart on Outposts servers

Parameters:
  StackName:
    Type: String
    Description: "Name of the CloudFormation stack"
  SourceInstanceId:
    Type: String
    Description: "ID of the source instance to monitor"
  NotificationEmail:
    Type: String
    Description: "Email address for SNS notifications"
  VpcId:
    Type: String
    Description: "VPC ID where the source instance is located"
  SubnetIds:
    Type: CommaDelimitedList
    Description: "Comma-delimited list of subnet IDs for Lambda function (private subnets with internet access)"

Resources:
  KMSKey:
    Type: AWS::KMS::Key
    UpdateReplacePolicy: Delete
    DeletionPolicy: Delete
    Properties:
      Description: 'KMS key for encrypting SNS topic data'
      EnableKeyRotation: true
      KeyPolicy:
        Version: '2012-10-17'
        Id: key-default-1
        Statement:
          - Sid: Allow administration of the key
            Effect: Allow
            Principal:
              AWS: !Sub 'arn:${AWS::Partition}:iam::${AWS::AccountId}:root'
            Action:
              - 'kms:*'
            Resource: '*'
          - Sid: Allow Cloudwatch to use the key
            Effect: Allow
            Principal:
              Service: cloudwatch.amazonaws.com
            Action:
              - kms:Encrypt
              - kms:Decrypt
              - kms:GenerateDataKey
              - kms:DescribeKey
            Resource: '*'
          - Sid: Allow Cloudwatch Logs to use the key
            Effect: Allow
            Principal:
              Service: logs.amazonaws.com
            Action:
              - kms:Encrypt
              - kms:Decrypt
              - kms:ReEncrypt*
              - kms:GenerateDataKey*
              - kms:DescribeKey
            Resource: '*'

  KMSKeyAlias:
    Type: AWS::KMS::Alias
    Properties:
      AliasName: !Sub 'alias/${AWS::StackName}-kmskey'
      TargetKeyId: !Ref KMSKey

  LambdaSNSTopic:
    Type: AWS::SNS::Topic
    Properties:
      DisplayName: "Outpost Server Notification"
      KmsMasterKeyId: !Ref KMSKey
      Tags:
        - Key: 'CreatedBy'
          Value: 'AutoRestartStack'

  EmailSNSTopic:
    Type: AWS::SNS::Topic
    Properties:
      DisplayName: "Outpost Server Email Notification"
      KmsMasterKeyId: !Ref KMSKey
      Tags:
        - Key: 'CreatedBy'
          Value: 'AutoRestartStack'

  EmailSNSTopicSubscription:
    Type: AWS::SNS::Subscription
    Properties:
      Protocol: email
      Endpoint: !Ref NotificationEmail
      TopicArn: !Ref EmailSNSTopic

  LambdaDLQ:
    Type: AWS::SQS::Queue
    Properties:
      QueueName: !Sub '${AWS::StackName}-lambda-dlq'
      KmsMasterKeyId: !Ref KMSKey
      MessageRetentionPeriod: 1209600  # 14 days
      Tags:
        - Key: 'CreatedBy'
          Value: 'AutoRestartStack'

  LambdaExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaVPCAccessExecutionRole
      Tags:
        - Key: 'CreatedBy'
          Value: 'AutoRestartStack'

  LambdaEC2Policy:
    Type: AWS::IAM::Policy
    Properties:
      PolicyName: LambdaEC2Policy
      Roles:
        - !Ref LambdaExecutionRole
      PolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Action:
              - ec2:RunInstances
            Resource:
              - !Sub 'arn:aws:ec2:${AWS::Region}:${AWS::AccountId}:instance/*'
              - !Sub 'arn:aws:ec2:${AWS::Region}:${AWS::AccountId}:volume/*'
              - !Sub 'arn:aws:ec2:${AWS::Region}:${AWS::AccountId}:network-interface/*'
              - !Sub 'arn:aws:ec2:${AWS::Region}:${AWS::AccountId}:subnet/*'
              - !Sub 'arn:aws:ec2:${AWS::Region}:${AWS::AccountId}:security-group/*'
              - !Sub 'arn:aws:ec2:${AWS::Region}:${AWS::AccountId}:launch-template/*'
              - !Sub 'arn:aws:ec2:${AWS::Region}::image/*'
              - !Sub 'arn:aws:ec2:${AWS::Region}:${AWS::AccountId}:key-pair/*'
            Condition:
              StringEquals:
                'aws:RequestedRegion': !Ref 'AWS::Region'
          - Effect: Allow
            Action:
              - ec2:CreateTags
            Resource: !Sub 'arn:aws:ec2:${AWS::Region}:${AWS::AccountId}:instance/*'
            Condition:
              StringEquals:
                'ec2:CreateAction': 'RunInstances'
          - Effect: Allow
            Action:
              - ec2:DescribeInstances
            Resource: '*'
          - Effect: Allow
            Action:
              - ec2:DescribeLaunchTemplates
            Resource: '*'

  LambdaLoadBalancerPolicy:
    Type: AWS::IAM::Policy
    Properties:
      PolicyName: LambdaLoadBalancerPolicy
      Roles:
        - !Ref LambdaExecutionRole
      PolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Action:
              - elasticloadbalancing:DescribeTargetGroups
              - elasticloadbalancing:DescribeTargetHealth
            Resource: '*'
          - Effect: Allow
            Action:
              - elasticloadbalancing:RegisterTargets
              - elasticloadbalancing:DeregisterTargets
            Resource: !Sub 'arn:aws:elasticloadbalancing:${AWS::Region}:${AWS::AccountId}:targetgroup/*/*'

  LambdaMonitoringPolicy:
    Type: AWS::IAM::Policy
    Properties:
      PolicyName: LambdaMonitoringPolicy
      Roles:
        - !Ref LambdaExecutionRole
      PolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Action:
              - cloudformation:DescribeStacks
            Resource: !Sub 'arn:aws:cloudformation:${AWS::Region}:${AWS::AccountId}:stack/${AWS::StackName}/*'
          - Effect: Allow
            Action:
              - cloudwatch:DescribeAlarmHistory
            Resource: !Sub 'arn:aws:cloudwatch:${AWS::Region}:${AWS::AccountId}:alarm:InstanceStatusCheckAlarm-${AWS::StackName}'
          - Effect: Allow
            Action:
              - logs:CreateLogGroup
              - logs:CreateLogStream
              - logs:PutLogEvents
            Resource: !Sub 'arn:aws:logs:${AWS::Region}:${AWS::AccountId}:log-group:/aws/lambda/*'
          - Effect: Allow
            Action:
              - sns:Publish
            Resource:
              - !Ref LambdaSNSTopic
              - !Ref EmailSNSTopic

  LambdaUtilityPolicy:
    Type: AWS::IAM::Policy
    Properties:
      PolicyName: LambdaUtilityPolicy
      Roles:
        - !Ref LambdaExecutionRole
      PolicyDocument:
        Version: '2012-10-17'
        Statement:

          - Effect: Allow
            Action:
              - ssm:GetParameters
            Resource: !Sub 'arn:aws:ssm:${AWS::Region}:${AWS::AccountId}:parameter/${AWS::StackName}/*'
          - Effect: Allow
            Action:
              - sts:GetCallerIdentity
            Resource: '*'

          - Effect: Allow
            Action:
              - kms:Decrypt
              - kms:GenerateDataKey
            Resource: !GetAtt KMSKey.Arn
          - Effect: Allow
            Action:
              - sqs:SendMessage
            Resource: !GetAtt LambdaDLQ.Arn

  LambdaSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: Security group for Lambda function
      VpcId: !Ref VpcId
      SecurityGroupEgress:
        - IpProtocol: tcp
          FromPort: 443
          ToPort: 443
          CidrIp: 0.0.0.0/0
          Description: HTTPS outbound for AWS API calls
      Tags:
        - Key: 'CreatedBy'
          Value: 'AutoRestartStack'

  LambdaFunction:
    Type: AWS::Lambda::Function
    DependsOn:
      - LambdaUtilityPolicy
      - LambdaMonitoringPolicy
      - LambdaLoadBalancerPolicy
      - LambdaEC2Policy
    Properties:
      Handler: index.lambda_handler
      Role: !GetAtt LambdaExecutionRole.Arn
      Runtime: python3.8
      ReservedConcurrentExecutions: 1
      KmsKeyArn: !GetAtt KMSKey.Arn
      VpcConfig:
        SecurityGroupIds:
          - !Ref LambdaSecurityGroup
        SubnetIds: !Ref SubnetIds
      Environment:
        Variables:
          STACK_NAME: !Ref StackName
          SOURCE_INSTANCE_ID: !Ref SourceInstanceId
          LAMBDA_SNS_TOPIC_ARN: !Ref LambdaSNSTopic
          EMAIL_SNS_TOPIC_ARN: !Ref EmailSNSTopic
      DeadLetterConfig:
        TargetArn: !GetAtt LambdaDLQ.Arn
      Tags:
        - Key: 'CreatedBy'
          Value: 'AutoRestartStack'

      Code:
        ZipFile: |
          import os
          import boto3
          from botocore.exceptions import ClientError, WaiterError
          
          # Retrieve launch template IDs from CloudFormation stack
          def get_launch_template_ids(stack_name):
            cloudformation = boto3.client("cloudformation")
            try:
              stack_details = cloudformation.describe_stacks(StackName=stack_name)
              outputs = stack_details["Stacks"][0]["Outputs"]
              launch_template_ids = []
              for output in outputs:
                if output["OutputKey"].startswith("LaunchTemplateId"):
                  launch_template_ids.append(output["OutputValue"])
              if not launch_template_ids:
                raise Exception(f"Launch template IDs not found in stack {stack_name}.")
              return launch_template_ids
            except Exception as e:
              print(f"Error retrieving launch template IDs: {str(e)}")
              return None
          
          # Update ALB if ALB exists for the source instance
          def update_alb_target_group(source_instance_id, new_instance_ids):
            ec2 = boto3.client('ec2')
            elbv2 = boto3.client('elbv2')
        
            try:
              # Find target group containing the source instance
              target_groups = elbv2.describe_target_groups()
              target_group_arn = None
              existing_instances = []
        
              for tg in target_groups['TargetGroups']:
                health = elbv2.describe_target_health(TargetGroupArn=tg['TargetGroupArn'])
                tg_instances = [target['Target']['Id'] for target in health['TargetHealthDescriptions']]
                
                # Check if source instance is in this target group
                if source_instance_id in tg_instances:
                  target_group_arn = tg['TargetGroupArn']
                  existing_instances = [source_instance_id]  # Only deregister the failed instance
                  break
        
              if not target_group_arn:
                return "No ALB target group was found for the source instance."
        
              print(f"Found target group: {target_group_arn}")
              print(f"Source instance in target group: {source_instance_id}")
        
              # Register new instances to the target group
              if new_instance_ids:
                  print(f"Attempting to register new instances: {new_instance_ids}")
                  elbv2.register_targets(
                      TargetGroupArn=target_group_arn,
                      Targets=[{'Id': id} for id in new_instance_ids]
                  )
                  print(f"Successfully registered new instances: {new_instance_ids}")
        
              # Deregister failed instance from the target group
              if existing_instances:
                  print(f"Attempting to deregister failed instance: {existing_instances}")
                  elbv2.deregister_targets(
                      TargetGroupArn=target_group_arn,
                      Targets=[{'Id': id} for id in existing_instances]
                  )
                  print(f"Successfully deregistering failed instance: {existing_instances}")
        
              # Verify the current state of the target group
              current_health = elbv2.describe_target_health(TargetGroupArn=target_group_arn)
              current_instances = [target['Target']['Id'] for target in current_health['TargetHealthDescriptions']]
              print(f"Current instances in target group: {current_instances}")
        
              return f"New instances registered and failed instance deregistered from target group {target_group_arn}. Current instances: {current_instances}."
            except ClientError as e:
              return f"Error updating ALB target group: {str(e)}"
          
          # Wait for newly launched instances to enter 'running' state
          def wait_for_instances_running(instance_ids, max_attempts=30):
            ec2 = boto3.client('ec2')
            waiter = ec2.get_waiter('instance_running')
            try:
              print(f"Waiting for instances {instance_ids} to enter 'running' state")
              waiter.wait(
                InstanceIds=instance_ids,
                WaiterConfig={
                  'Delay': 15,
                  'MaxAttempts': max_attempts
                }
              )
              print(f"All instances are now in 'running' state")
              return True
            except WaiterError as e:
              print(f"Not all instances are in 'running' state after {max_attempts} attempts: {e}")
              return False
          
          # Main Lambda handler
          def lambda_handler(event, context):
              stack_name = os.getenv("STACK_NAME")
              source_instance_id = os.getenv("SOURCE_INSTANCE_ID")
              lambda_sns_topic_arn = os.getenv("LAMBDA_SNS_TOPIC_ARN")
              email_sns_topic_arn = os.getenv("EMAIL_SNS_TOPIC_ARN")
          
              print(f"Received event: {event}")
              print(f"Stack Name: {stack_name}")
              print(f"Source Instance ID: {source_instance_id}")
              print(f"Lambda SNS Topic ARN: {lambda_sns_topic_arn}")
              print(f"Email SNS Topic ARN: {email_sns_topic_arn}")
          
              # Check if this is a new alarm state
              cloudwatch = boto3.client('cloudwatch')
              alarm_name = f"InstanceStatusCheckAlarm-{stack_name}"
          
              try:
                  alarm_history = cloudwatch.describe_alarm_history(
                      AlarmName=alarm_name,
                      HistoryItemType='StateUpdate',
                      MaxRecords=2
                  )
          
                  if len(alarm_history['AlarmHistoryItems']) >= 2:
                      current_state = alarm_history['AlarmHistoryItems'][0]['HistorySummary']
                      previous_state = alarm_history['AlarmHistoryItems'][1]['HistorySummary']
          
                      # Do not re-alarm if the instance is already in alarm state
                      if 'ALARM' in current_state and 'ALARM' in previous_state:
                          print(f"Alarm {alarm_name} is already in ALARM state. Skipping action.")
                          return
              except ClientError as e:
                  print(f"Error checking alarm history: {e}")
          
              instance_ids = []
              alb_message = ""
          
              try:
                  # Grab launch template IDs to prepare to launch
                  launch_template_ids = get_launch_template_ids(stack_name)
                  if not launch_template_ids:
                    raise Exception("No launch template IDs found.")
          
                  print(f"Retrieved launch template IDs: {launch_template_ids}")
                  ec2 = boto3.client("ec2")
          
                  # # Get launch template names to check for duplicates
                  # template_names = []
                  # for template_id in launch_template_ids:
                  #     template_response = ec2.describe_launch_templates(LaunchTemplateIds=[template_id])
                  #     template_name = template_response['LaunchTemplates'][0]['LaunchTemplateName']
                  #     template_names.append(template_name)
                  # print(f"Template names to check: {template_names}")
                  # 
                  # # Check if instances with same names are already running
                  # existing_instances = ec2.describe_instances(
                  #     Filters=[
                  #         {'Name': 'instance-state-name', 'Values': ['running', 'pending']}
                  #     ]
                  # )
                  # print(f"Found {len([i for r in existing_instances['Reservations'] for i in r['Instances']])} running/pending instances total")
                  # 
                  # duplicate_instances = []
                  # for reservation in existing_instances['Reservations']:
                  #     for instance in reservation['Instances']:
                  #         instance_name = next((tag['Value'] for tag in instance.get('Tags', []) if tag['Key'] == 'Name'), None)
                  #         instance_state = instance['State']['Name']
                  #         print(f"Checking instance: {instance['InstanceId']} name='{instance_name}' state={instance_state}")
                  #         if instance_name and instance_state in ['running', 'pending']:
                  #             # Check if instance name matches any template name pattern
                  #             for template_name in template_names:
                  #                 if instance_name in template_name or template_name in instance_name:
                  #                     print(f"Found duplicate instance: {instance['InstanceId']} ({instance_name}) matches template {template_name} - State: {instance_state}")
                  #                     duplicate_instances.append({'id': instance['InstanceId'], 'name': instance_name, 'state': instance_state})
                  #                     break
                  # 
                  # print(f"Duplicate instances found: {len(duplicate_instances)}")
                  # if duplicate_instances:
                  #     instance_list = [f"{inst['id']} ({inst['name']}) - {inst['state']}" for inst in duplicate_instances]
                  #     print(f"Found existing instances with same names: {instance_list}")
                  #     print("Skipping instance launch to prevent duplicates.")
                  #     return
                  # else:
                  #     print("No duplicate instances found, proceeding with launch.")
          
                  # Launch an EC2 instance for every launch template ID provided
                  for launch_template_id in launch_template_ids:
                      try:
                          print(f"Launching new instance with launch template ID: {launch_template_id}")
                          launch_response = ec2.run_instances(
                              LaunchTemplate={"LaunchTemplateId": launch_template_id},
                              MinCount=1,
                              MaxCount=1,
                          )
                          instance_id = launch_response["Instances"][0]["InstanceId"]
                          instance_ids.append(instance_id)
                          print(f"Launched instance: {instance_id}")
                      except ClientError as e:
                          print(f"Error launching instance with launch template ID {launch_template_id}: {e}")
                          raise
          
                  print(f"Launching instances: {instance_ids}")
          
                  # Wait for instances to enter 'running' state
                  if not wait_for_instances_running(instance_ids):
                    raise Exception("Timeout waiting for instances to enter 'running' state")
                  print(f"Instances are now in running state: {instance_ids}")
          
                  # Update ALB if ALB exists
                  alb_message = update_alb_target_group(source_instance_id, instance_ids)
          
                  # Send e-mail via SNS
                  email_sns = boto3.client("sns")
                  try:
                      message = f"Instance {source_instance_id} failed status checks. Recovery instances have successfully launched: {', '.join(instance_ids)}. {alb_message} Instance status can be monitored on EC2."
                      email_sns.publish(
                          TopicArn=email_sns_topic_arn,
                          Message=message,
                          Subject="Instance Recovery Success"
                      )
                      print(f"Published success message to SNS topic: {message}")
                  except ClientError as e:
                      print(f"Error publishing success message to SNS topic: {e}")
                      raise

              except Exception as e:
                  print(f"Error in lambda_handler: {str(e)}")
          
                  email_sns = boto3.client("sns")
                  try:
                      if instance_ids:
                        message_intro = f"Instance {source_instance_id} failed status checks. Recovery was attempted but failed with error below, though the following instances were successfully launched: {instance_ids}."
                      else:
                        message_intro = f"Instance {source_instance_id} failed status checks. Recovery was attempted but failed with error:"
                      message = f"""{message_intro}
          
          {str(e)}

          Please manually resolve and re-launch.

          Note: In the case of insufficient capacity, the instances may have successfully relaunched but are not associated with an Outpost."""
                      email_sns.publish(
                          TopicArn=email_sns_topic_arn,
                          Message=message,
                          Subject="Instance Recovery Failure"
                      )
                      print(f"Published error message to SNS topic: {message}")
                  except ClientError as e:
                      print(f"Error publishing error message to SNS topic: {e}")
                      raise

      Runtime: python3.8
      Timeout: 900 # Set timeout 15 minutes

  LambdaInvokePermission:
    Type: AWS::Lambda::Permission
    Properties:
      Action: lambda:InvokeFunction
      FunctionName: !Ref LambdaFunction
      Principal: sns.amazonaws.com
      SourceArn: !Ref LambdaSNSTopic

  LambdaSNSTopicSubscription:
    Type: AWS::SNS::Subscription
    Properties:
      Protocol: lambda
      Endpoint: !GetAtt LambdaFunction.Arn
      TopicArn: !Ref LambdaSNSTopic

  InstanceStatusCheckAlarm:
    Type: AWS::CloudWatch::Alarm
    Properties:
      AlarmDescription: "Alarm when instance status check fails. Failure means StatusCheckFailed_Instance is 1 for 4 datapoints within 4 minutes"
      AlarmName: !Sub "InstanceStatusCheckAlarm-${AWS::StackName}"
      EvaluationPeriods: 4
      DatapointsToAlarm: 4
      Threshold: 0
      ComparisonOperator: "GreaterThanThreshold"
      MetricName: "StatusCheckFailed_Instance"
      Namespace: "AWS/EC2"
      Statistic: "Maximum"
      Period: 60
      Dimensions:
        - Name: "InstanceId"
          Value: !Ref SourceInstanceId
      AlarmActions:
        - !Ref LambdaSNSTopic

Outputs:
  # Outputs will be dynamically inserted here